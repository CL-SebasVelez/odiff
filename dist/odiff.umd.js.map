{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///odiff.umd.js","webpack:///webpack/bootstrap 884e7dd019b7cef52886","webpack:///./billysFile/code/javascript/modules/odiff/odiff.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","findMatchIndexes","compareFn","a","b","divergenceIndexA","divergenceIndexB","aSubMin","bSubMin","maxNForA","maxNForB","maxN","Math","max","n","newestA","newestB","j","elemA","elemB","similar","Array","tenPercent","length","notEqual","abs","equal","Object","keyMap","merge","arrayToMap","keys","keyLength","key","aVal","bVal","isNaN","aKeys","bKeys","array","result","forEach","v","obj1","obj2","results","diffInternal","acc","base","set","changeList","property","value","push","type","path","val","rm","index","count","num","add","values","vals","Number","an","bn","indexes","anInner","bnInner","concat","indexesInner","numberPulled","numberPushed","slice"],"mappings":"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","file":"odiff.umd.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"odiff\"] = factory();\n\telse\n\t\troot[\"odiff\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"odiff\"] = factory();\n\telse\n\t\troot[\"odiff\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t\r\n\t/* Copyright (c) 2013 Billy Tetrud - Free to use for any purpose: MIT License*/\r\n\t// gets the changes that need to happen to a to change it into b\r\n\t// returns an object with the members\r\n\t    // type\r\n\t    // property\r\n\t    // value\r\n\t    // values\r\n\t    // count\r\n\tmodule.exports = function(a,b) {\r\n\t    var results = []\r\n\t    diffInternal(a,b,results,[])\r\n\t    return results\r\n\t}\r\n\t\r\n\tvar diffInternal = function(a,b,acc,base) {\r\n\t    if(a === b || Number.isNaN(a)&&Number.isNaN(b)) {\r\n\t        return;\r\n\t    } else if(a instanceof Array && b instanceof Array) {\r\n\t        var an=a.length-1,bn=b.length-1\r\n\t        while(an >= 0 && bn >= 0) {     // loop backwards (so that making changes in order will work correctly)\r\n\t            if(!equal(a[an], b[bn])) {\r\n\t                var indexes = findMatchIndexes(equal, a,b, an,bn, 0, 0)\r\n\t\r\n\t                var anInner=an,bnInner=bn\r\n\t                while(anInner > indexes.a && bnInner > indexes.b) {\r\n\t                    if(similar(a[anInner], b[bnInner])) {\r\n\t                        // get change for that element\r\n\t                        diffInternal(a[anInner],b[bnInner],acc, base.concat([anInner]))\r\n\t                        anInner--; bnInner--;\r\n\t                    } else {\r\n\t                        var indexesInner = findMatchIndexes(similar, a,b, anInner,bnInner, indexes.a+1, indexes.b+1)\r\n\t\r\n\t                        var numberPulled = anInner-indexesInner.a\r\n\t                        var numberPushed = bnInner-indexesInner.b\r\n\t\r\n\t                        if(numberPulled === 1 && numberPushed === 1) {\r\n\t                            set(acc, base.concat(indexesInner.a+1), b[indexesInner.b+1]) // set the one\r\n\t                        } else if(numberPulled === 1 && numberPushed === 2) {\r\n\t                            // set one, push the other\r\n\t                            add(acc, base,indexesInner.a+2, b.slice(indexesInner.b+2, bnInner+1))\r\n\t                            set(acc, base.concat(indexesInner.a+1), b[indexesInner.b+1])\r\n\t                        } else if(numberPulled === 2 && numberPushed === 1) {\r\n\t                            // set one, pull the other\r\n\t                            rm(acc, base, indexesInner.a+2, 1)\r\n\t                            set(acc, base.concat(indexesInner.a+1), b[indexesInner.b+1])\r\n\t                        } else if(numberPulled === 2 && numberPushed === 2) {\r\n\t                            set(acc, base.concat(indexesInner.a+2), b[indexesInner.b+2])\r\n\t                            set(acc, base.concat(indexesInner.a+1), b[indexesInner.b+1])\r\n\t                        } else {\r\n\t                            if(numberPulled > 0) { // if there were some elements pulled\r\n\t                                rm(acc, base, indexesInner.a+1, numberPulled)\r\n\t                            }\r\n\t                            if(numberPushed > 0) { // if there were some elements pushed\r\n\t                                add(acc, base,indexesInner.a+1, b.slice(indexesInner.b+1, bnInner+1))\r\n\t                            }\r\n\t                        }\r\n\t\r\n\t                        anInner = indexesInner.a\r\n\t                        bnInner = indexesInner.b\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                if(anInner > indexes.a) {        // more to pull\r\n\t                    rm(acc, base, anInner, anInner-indexes.a)\r\n\t                } else if(bnInner > indexes.b) { // more to push\r\n\t                    add(acc, base, anInner+1, b.slice(indexes.b+1, bnInner+1))\r\n\t                }\r\n\t\r\n\t                an = indexes.a\r\n\t                bn = indexes.b\r\n\t            } else {\r\n\t                an--; bn--;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        if(an >= 0) {        // more to pull\r\n\t            rm(acc, base, 0, an+1)\r\n\t        } else if(bn >= 0) { // more to push\r\n\t            add(acc, base,0, b.slice(0, bn+1))\r\n\t        }\r\n\t\r\n\t    } else if(a instanceof Object && b instanceof Object) {\r\n\t        var keyMap = merge(arrayToMap(Object.keys(a)), arrayToMap(Object.keys(b)))\r\n\t        for(var key in keyMap) {\r\n\t            var path = base.concat([key])\r\n\t            diffInternal(a[key],b[key],acc, path)\r\n\t        }\r\n\t    } else {\r\n\t        set(acc, base, b)\r\n\t    }\r\n\t\r\n\t    // adds an 'set' type to the changeList\r\n\t    function set(changeList, property, value) {\r\n\t        changeList.push({\r\n\t            type:'set',\r\n\t            path: property,\r\n\t            val: value\r\n\t        })\r\n\t    }\r\n\t\r\n\t    // adds an 'rm' type to the changeList\r\n\t    function rm(changeList, property, index, count) {\r\n\t        changeList.push({\r\n\t            type:'rm',\r\n\t            path: property,\r\n\t            index: index,\r\n\t            num: count\r\n\t        })\r\n\t    }\r\n\t\r\n\t    // adds an 'add' type to the changeList\r\n\t    function add(changeList, property, index, values) {\r\n\t        changeList.push({\r\n\t            type:'add',\r\n\t            path: property,\r\n\t            index: index,\r\n\t            vals: values\r\n\t        })\r\n\t    }\r\n\t}\r\n\t\r\n\tmodule.exports.similar = similar\r\n\tmodule.exports.equal = equal\r\n\t\r\n\t\r\n\t// finds and returns the closest indexes in a and b that match starting with divergenceIndex\r\n\t// note: loops backwards like the rest of this stuff\r\n\t// returns the index beyond the first element (aSubMin-1 or bSubMin-1) for each if there is no match\r\n\t// parameters:\r\n\t    // compareFn - determines what matches (returns true if the arguments match)\r\n\t    // a,b - two arrays to compare\r\n\t    // divergenceIndexA,divergenceIndexB - the two positions of a and b to start comparing from\r\n\t    // aSubMin,bSubMin - the two positions to compare until\r\n\tfunction findMatchIndexes(compareFn, a,b, divergenceIndexA,divergenceIndexB, aSubMin, bSubMin) {\r\n\t    var maxNForA = divergenceIndexA-aSubMin\r\n\t    var maxNForB = divergenceIndexB-bSubMin\r\n\t    var maxN = Math.max(maxNForA, maxNForB)\r\n\t    for(var n=1; n<=maxN; n++) {\r\n\t        var newestA = a[divergenceIndexA-n] // the current item farthest from the divergence index being compared\r\n\t        var newestB = b[divergenceIndexB-n]\r\n\t\r\n\t        if(n<=maxNForB && n<=maxNForA && compareFn(newestA, newestB)) {\r\n\t            return {a:divergenceIndexA-n, b:divergenceIndexB-n}\r\n\t        }\r\n\t\r\n\t        for(var j=0; j<n; j++) {\r\n\t            var elemA = a[divergenceIndexA-j] // an element between the divergence index and the newest items\r\n\t            var elemB = b[divergenceIndexB-j]\r\n\t\r\n\t            if(n<=maxNForB && compareFn(elemA, newestB)) {\r\n\t                return {a:divergenceIndexA-j, b:divergenceIndexB-n}\r\n\t            } else if(n<=maxNForA && compareFn(newestA, elemB)) {\r\n\t                return {a:divergenceIndexA-n, b:divergenceIndexB-j}\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    // else\r\n\t    return {a: aSubMin-1, b: bSubMin-1}\r\n\t}\r\n\t\r\n\t\r\n\t// compares arrays and objects and returns true if they're similar meaning:\r\n\t    // less than 2 changes, or\r\n\t    // less than 10% different members\r\n\tfunction similar(a,b) {\r\n\t    if(a instanceof Array) {\r\n\t        if(!(b instanceof Array))\r\n\t            return false\r\n\t\r\n\t        var tenPercent = a.length/10\r\n\t        var notEqual = Math.abs(a.length-b.length) // initialize with the length difference\r\n\t        for(var n=0; n<a.length; n++) {\r\n\t            if(equal(a[n],b[n])) {\r\n\t                if(notEqual >= 2 && notEqual > tenPercent || notEqual === a.length) {\r\n\t                    return false\r\n\t                }\r\n\t\r\n\t                notEqual++\r\n\t            }\r\n\t        }\r\n\t        // else\r\n\t        return true\r\n\t\r\n\t    } else if(a instanceof Object) {\r\n\t        if(!(b instanceof Object))\r\n\t            return false\r\n\t\r\n\t        var keyMap = merge(arrayToMap(Object.keys(a)), arrayToMap(Object.keys(b)))\r\n\t        var keyLength = Object.keys(keyMap).length\r\n\t        var tenPercent = keyLength / 10\r\n\t        var notEqual = 0\r\n\t        for(var key in keyMap) {\r\n\t            var aVal = a[key]\r\n\t            var bVal = b[key]\r\n\t\r\n\t            if(!equal(aVal,bVal)) {\r\n\t                if(notEqual >= 2 && notEqual > tenPercent || notEqual+1 === keyLength) {\r\n\t                    return false\r\n\t                }\r\n\t\r\n\t                notEqual++\r\n\t            }\r\n\t        }\r\n\t        // else\r\n\t        return true\r\n\t\r\n\t    } else {\r\n\t        return a===b || isNaN(a) && isNaN(b)\r\n\t    }\r\n\t}\r\n\t\r\n\t// compares arrays and objects for value equality (all elements and members must match)\r\n\tfunction equal(a,b) {\r\n\t    if(a instanceof Array) {\r\n\t        if(!(b instanceof Array))\r\n\t            return false\r\n\t        if(a.length !== b.length) {\r\n\t            return false\r\n\t        } else {\r\n\t            for(var n=0; n<a.length; n++) {\r\n\t                if(!equal(a[n],b[n])) {\r\n\t                    return false\r\n\t                }\r\n\t            }\r\n\t            // else\r\n\t            return true\r\n\t        }\r\n\t    } else if(a instanceof Object) {\r\n\t        if(!(b instanceof Object))\r\n\t            return false\r\n\t\r\n\t        var aKeys = Object.keys(a)\r\n\t        var bKeys = Object.keys(b)\r\n\t\r\n\t        if(aKeys.length !== bKeys.length) {\r\n\t            return false\r\n\t        } else {\r\n\t            for(var n=0; n<aKeys.length; n++) {\r\n\t                var key = aKeys[n]\r\n\t                var aVal = a[key]\r\n\t                var bVal = b[key]\r\n\t\r\n\t                if(!equal(aVal,bVal)) {\r\n\t                    return false\r\n\t                }\r\n\t            }\r\n\t            // else\r\n\t            return true\r\n\t        }\r\n\t    } else {\r\n\t        return a===b || isNaN(a) && isNaN(b)\r\n\t    }\r\n\t}\r\n\t\r\n\t\r\n\t// turns an array of values into a an object where those values are all keys that point to 'true'\r\n\tfunction arrayToMap(array) {\r\n\t    var result = {}\r\n\t    array.forEach(function(v) {\r\n\t        result[v] = true\r\n\t    })\r\n\t    return result\r\n\t}\r\n\t\r\n\t// Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1\r\n\t// returns obj1 (now mutated)\r\n\tfunction merge(obj1, obj2){\r\n\t    for(var key in obj2){\r\n\t        obj1[key] = obj2[key]\r\n\t    }\r\n\t\r\n\t    return obj1\r\n\t}\r\n\t\r\n\n\n/***/ }\n/******/ ])\n});\n\n\n\n/** WEBPACK FOOTER **\n ** odiff.umd.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 884e7dd019b7cef52886\n **/","\"use strict\";\r\n\r\n/* Copyright (c) 2013 Billy Tetrud - Free to use for any purpose: MIT License*/\r\n// gets the changes that need to happen to a to change it into b\r\n// returns an object with the members\r\n    // type\r\n    // property\r\n    // value\r\n    // values\r\n    // count\r\nmodule.exports = function(a,b) {\r\n    var results = []\r\n    diffInternal(a,b,results,[])\r\n    return results\r\n}\r\n\r\nvar diffInternal = function(a,b,acc,base) {\r\n    if(a === b || Number.isNaN(a)&&Number.isNaN(b)) {\r\n        return;\r\n    } else if(a instanceof Array && b instanceof Array) {\r\n        var an=a.length-1,bn=b.length-1\r\n        while(an >= 0 && bn >= 0) {     // loop backwards (so that making changes in order will work correctly)\r\n            if(!equal(a[an], b[bn])) {\r\n                var indexes = findMatchIndexes(equal, a,b, an,bn, 0, 0)\r\n\r\n                var anInner=an,bnInner=bn\r\n                while(anInner > indexes.a && bnInner > indexes.b) {\r\n                    if(similar(a[anInner], b[bnInner])) {\r\n                        // get change for that element\r\n                        diffInternal(a[anInner],b[bnInner],acc, base.concat([anInner]))\r\n                        anInner--; bnInner--;\r\n                    } else {\r\n                        var indexesInner = findMatchIndexes(similar, a,b, anInner,bnInner, indexes.a+1, indexes.b+1)\r\n\r\n                        var numberPulled = anInner-indexesInner.a\r\n                        var numberPushed = bnInner-indexesInner.b\r\n\r\n                        if(numberPulled === 1 && numberPushed === 1) {\r\n                            set(acc, base.concat(indexesInner.a+1), b[indexesInner.b+1]) // set the one\r\n                        } else if(numberPulled === 1 && numberPushed === 2) {\r\n                            // set one, push the other\r\n                            add(acc, base,indexesInner.a+2, b.slice(indexesInner.b+2, bnInner+1))\r\n                            set(acc, base.concat(indexesInner.a+1), b[indexesInner.b+1])\r\n                        } else if(numberPulled === 2 && numberPushed === 1) {\r\n                            // set one, pull the other\r\n                            rm(acc, base, indexesInner.a+2, 1)\r\n                            set(acc, base.concat(indexesInner.a+1), b[indexesInner.b+1])\r\n                        } else if(numberPulled === 2 && numberPushed === 2) {\r\n                            set(acc, base.concat(indexesInner.a+2), b[indexesInner.b+2])\r\n                            set(acc, base.concat(indexesInner.a+1), b[indexesInner.b+1])\r\n                        } else {\r\n                            if(numberPulled > 0) { // if there were some elements pulled\r\n                                rm(acc, base, indexesInner.a+1, numberPulled)\r\n                            }\r\n                            if(numberPushed > 0) { // if there were some elements pushed\r\n                                add(acc, base,indexesInner.a+1, b.slice(indexesInner.b+1, bnInner+1))\r\n                            }\r\n                        }\r\n\r\n                        anInner = indexesInner.a\r\n                        bnInner = indexesInner.b\r\n                    }\r\n                }\r\n\r\n                if(anInner > indexes.a) {        // more to pull\r\n                    rm(acc, base, anInner, anInner-indexes.a)\r\n                } else if(bnInner > indexes.b) { // more to push\r\n                    add(acc, base, anInner+1, b.slice(indexes.b+1, bnInner+1))\r\n                }\r\n\r\n                an = indexes.a\r\n                bn = indexes.b\r\n            } else {\r\n                an--; bn--;\r\n            }\r\n        }\r\n\r\n        if(an >= 0) {        // more to pull\r\n            rm(acc, base, 0, an+1)\r\n        } else if(bn >= 0) { // more to push\r\n            add(acc, base,0, b.slice(0, bn+1))\r\n        }\r\n\r\n    } else if(a instanceof Object && b instanceof Object) {\r\n        var keyMap = merge(arrayToMap(Object.keys(a)), arrayToMap(Object.keys(b)))\r\n        for(var key in keyMap) {\r\n            var path = base.concat([key])\r\n            diffInternal(a[key],b[key],acc, path)\r\n        }\r\n    } else {\r\n        set(acc, base, b)\r\n    }\r\n\r\n    // adds an 'set' type to the changeList\r\n    function set(changeList, property, value) {\r\n        changeList.push({\r\n            type:'set',\r\n            path: property,\r\n            val: value\r\n        })\r\n    }\r\n\r\n    // adds an 'rm' type to the changeList\r\n    function rm(changeList, property, index, count) {\r\n        changeList.push({\r\n            type:'rm',\r\n            path: property,\r\n            index: index,\r\n            num: count\r\n        })\r\n    }\r\n\r\n    // adds an 'add' type to the changeList\r\n    function add(changeList, property, index, values) {\r\n        changeList.push({\r\n            type:'add',\r\n            path: property,\r\n            index: index,\r\n            vals: values\r\n        })\r\n    }\r\n}\r\n\r\nmodule.exports.similar = similar\r\nmodule.exports.equal = equal\r\n\r\n\r\n// finds and returns the closest indexes in a and b that match starting with divergenceIndex\r\n// note: loops backwards like the rest of this stuff\r\n// returns the index beyond the first element (aSubMin-1 or bSubMin-1) for each if there is no match\r\n// parameters:\r\n    // compareFn - determines what matches (returns true if the arguments match)\r\n    // a,b - two arrays to compare\r\n    // divergenceIndexA,divergenceIndexB - the two positions of a and b to start comparing from\r\n    // aSubMin,bSubMin - the two positions to compare until\r\nfunction findMatchIndexes(compareFn, a,b, divergenceIndexA,divergenceIndexB, aSubMin, bSubMin) {\r\n    var maxNForA = divergenceIndexA-aSubMin\r\n    var maxNForB = divergenceIndexB-bSubMin\r\n    var maxN = Math.max(maxNForA, maxNForB)\r\n    for(var n=1; n<=maxN; n++) {\r\n        var newestA = a[divergenceIndexA-n] // the current item farthest from the divergence index being compared\r\n        var newestB = b[divergenceIndexB-n]\r\n\r\n        if(n<=maxNForB && n<=maxNForA && compareFn(newestA, newestB)) {\r\n            return {a:divergenceIndexA-n, b:divergenceIndexB-n}\r\n        }\r\n\r\n        for(var j=0; j<n; j++) {\r\n            var elemA = a[divergenceIndexA-j] // an element between the divergence index and the newest items\r\n            var elemB = b[divergenceIndexB-j]\r\n\r\n            if(n<=maxNForB && compareFn(elemA, newestB)) {\r\n                return {a:divergenceIndexA-j, b:divergenceIndexB-n}\r\n            } else if(n<=maxNForA && compareFn(newestA, elemB)) {\r\n                return {a:divergenceIndexA-n, b:divergenceIndexB-j}\r\n            }\r\n        }\r\n    }\r\n    // else\r\n    return {a: aSubMin-1, b: bSubMin-1}\r\n}\r\n\r\n\r\n// compares arrays and objects and returns true if they're similar meaning:\r\n    // less than 2 changes, or\r\n    // less than 10% different members\r\nfunction similar(a,b) {\r\n    if(a instanceof Array) {\r\n        if(!(b instanceof Array))\r\n            return false\r\n\r\n        var tenPercent = a.length/10\r\n        var notEqual = Math.abs(a.length-b.length) // initialize with the length difference\r\n        for(var n=0; n<a.length; n++) {\r\n            if(equal(a[n],b[n])) {\r\n                if(notEqual >= 2 && notEqual > tenPercent || notEqual === a.length) {\r\n                    return false\r\n                }\r\n\r\n                notEqual++\r\n            }\r\n        }\r\n        // else\r\n        return true\r\n\r\n    } else if(a instanceof Object) {\r\n        if(!(b instanceof Object))\r\n            return false\r\n\r\n        var keyMap = merge(arrayToMap(Object.keys(a)), arrayToMap(Object.keys(b)))\r\n        var keyLength = Object.keys(keyMap).length\r\n        var tenPercent = keyLength / 10\r\n        var notEqual = 0\r\n        for(var key in keyMap) {\r\n            var aVal = a[key]\r\n            var bVal = b[key]\r\n\r\n            if(!equal(aVal,bVal)) {\r\n                if(notEqual >= 2 && notEqual > tenPercent || notEqual+1 === keyLength) {\r\n                    return false\r\n                }\r\n\r\n                notEqual++\r\n            }\r\n        }\r\n        // else\r\n        return true\r\n\r\n    } else {\r\n        return a===b || isNaN(a) && isNaN(b)\r\n    }\r\n}\r\n\r\n// compares arrays and objects for value equality (all elements and members must match)\r\nfunction equal(a,b) {\r\n    if(a instanceof Array) {\r\n        if(!(b instanceof Array))\r\n            return false\r\n        if(a.length !== b.length) {\r\n            return false\r\n        } else {\r\n            for(var n=0; n<a.length; n++) {\r\n                if(!equal(a[n],b[n])) {\r\n                    return false\r\n                }\r\n            }\r\n            // else\r\n            return true\r\n        }\r\n    } else if(a instanceof Object) {\r\n        if(!(b instanceof Object))\r\n            return false\r\n\r\n        var aKeys = Object.keys(a)\r\n        var bKeys = Object.keys(b)\r\n\r\n        if(aKeys.length !== bKeys.length) {\r\n            return false\r\n        } else {\r\n            for(var n=0; n<aKeys.length; n++) {\r\n                var key = aKeys[n]\r\n                var aVal = a[key]\r\n                var bVal = b[key]\r\n\r\n                if(!equal(aVal,bVal)) {\r\n                    return false\r\n                }\r\n            }\r\n            // else\r\n            return true\r\n        }\r\n    } else {\r\n        return a===b || isNaN(a) && isNaN(b)\r\n    }\r\n}\r\n\r\n\r\n// turns an array of values into a an object where those values are all keys that point to 'true'\r\nfunction arrayToMap(array) {\r\n    var result = {}\r\n    array.forEach(function(v) {\r\n        result[v] = true\r\n    })\r\n    return result\r\n}\r\n\r\n// Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1\r\n// returns obj1 (now mutated)\r\nfunction merge(obj1, obj2){\r\n    for(var key in obj2){\r\n        obj1[key] = obj2[key]\r\n    }\r\n\r\n    return obj1\r\n}\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/modules/odiff/odiff.js\n ** module id = 0\n ** module chunks = 0\n **/"],"sourceRoot":""}